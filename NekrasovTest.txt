
ФИО    Какова разница между абстрактным классом и интерфейсом?

Абстрактный класс - это класс, экземпляр которого нельзя создать. Он может содержать классовые переменные и абстрактные методы, конкретная реализация которых не указана. Конкретные реализации появляются только в переопределенных методах в классах-наследниках. В отличие от интерфейса, класс может наследовать только от одного класса.
Интерфейс - это особый класс, который содержит дополнительные возможности, которые можно добавлять любому классу, реализующему этот метод. Это происходит с помощью ключевого слова implements, при этом класс обязан реализовать все методы из этого интерфейса (если реализованы не все методы, класс должен быть объявлен абстрактным).  В отличие от классов, интерфейсы поддерживают множественное наследование (наследование более, чем от одного интерфейса). Также нельзя создать экземпляр интерфейса. Существуют интерфейсы - метки, не содержащие методов, используемые для указания на гарантию определенной функциональности (например, clonable, интерфейс говорящий о том, что объект класса можно скопировать методом clone() и будет возвращена корректная копия объекта со всеми его полями)

      !_Как «насильно» вызвать сборку мусора
Сборка мусора - это очистка памяти, удаление из нее объектов, на которые больше нет ссылок. Такие объекты удаляются автоматически, нерегулярно и непредсказуемо, и для явного вызова сборщика мусора существуют специальные методы:
System.gc()
Runtime.getRuntime().gc()    Когда требуется явное приведение классов?
Приведение классов - это изменение типа, ссылка на объект которого содержится в переменной. 
Когда мы от более узкого типа переходим к более широкому (восходящее приведение, upcasting, расширение диапазона значений), явное приведение не нужно, так как содержание более узкого типа точно “поместится” в переменную более широкого типа
Оно нужно тогда, когда мы от более широкого типа переходим к более узкому, (нисходящее приведение, downcasting, сужение диапазона значений).
     !_Чем конструкторы отличаются от других методов?
Конструктор - это специальный метод, который описывает создание экземпляра класса.
Имя конструктора - такое же, как и у класса. Он вызывается при создании экземпляра класса с помощью ключевого слова new и имени класса, в котором находится. Если в классе конструктор не указан явно, то автоматически создается конструктор по умолчанию, без аргументов. Если же явно указан хотя бы один конструктор, то этот дефолтный конструктор не будет создан (т.е. конструктор без аргументов, если явно не указан, существует только в тех классах, где не указано ни одного конструктора). Конструктор не возвращает значения. 
Конструктор можно переопределить и перегрузить, как и обычный метод     !_Можно ли вызывать конструкторы один из другого, если их в классе несколько?
Если в классе несколько конструкторов, то один можно вызывать из другого, но только с помощью ключевого слова this и только если вызов будет первой строкой в блоке описания конструктора     !_В чем разница между JDK и JRE?
Java Runtime Environment - среда выполнения программ на java, содержит реализацию виртуальной java-машины, которая интерпретирует байт-код и необходима для работы любой программы на java
Java Developer Kit - набор базовых инструментов для разработки программ на java, в который также входит виртуальная java-машина, но кроме этого стандартные библиотеки, также компилятор, архиватор, javadoc для документирования кода и другие инструменты     Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
FileNotFoundException - подкласс IOException, и не имеет значения, в каком порядке их перехватывать, ведь catch-блок IOException в любом случае перехватит FileNotFoundException 
     !_Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
Внутренние классы, описаннные внутри метода (локальные или анонимные) имеют доступ к локальным переменным этого метода только при условии, что они объявлены final     !_Как подкласс может обратиться к методу или конструктору из суперкласса?
Для того, чтобы обратиться к методу суперкласса, его не нужно импортировать в класс, для этого существует специальное ключевое слово super, которое можно использовать вместо полного имени класса, из которого мы вызываем метод.
Если в классе, от которого наследует наш класс (тот, который вызывает метод), не находится метода с таким именем, то будет выполнен метод из следующего по иерархии метода (при наличии в нем такового), если же нет, то поиск пойдет далее по цепочке    !_В чем разница между очередью и стеком?

Очередь - набор элементов, в который элементы добавляются только в конец, а удаляются только из начала - принцип first in - first out, то есть элемент, попавший в очередь первым, выйдет из нее также первым
Стек - набор элементов, в который элементы как добаляются в начало, так и выходят из начала - last in - first out. Для иллюстрации можно представить магазин патронов для пистолета - первым в ствол пойдет верхний патрон, который мы зарядили в магазин последним     Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?

Young generation - область памяти, где содержатся недавно созданные объекты
Old Generation - область памяти, где содержатся объекты, которые “пережили” вызов сборщика мусора
В Young generation очистка памяти происходит чаще и быстрее, тогда как в old generation - медленнее и реже     Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?

Design Pattern - шаблон проектирования, устойчивый код, который позволяет экономить время на решение часто возникающих задач и гарантирует верную работу
В случае, описанном в вопросе, нужно реализовать шаблон проектирования Наблюдатель (Observer), так как он создает в классе механихм, который позволяет “наблюдать” за другими классами, получая оповещения при изменении состояния других классов     !_Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
Существует три модификатора доступа и четыре уровня доступа:
public - элемент доступен всем классам
protected - элемент доступен в классе и наследникам этого класса
default (если модификатор отсутствует. Это уровень доступа по умолчанию) - элемент доступен только классам, находящимся в том же пакете
private - элемент доступен только классу, в котором находится

Если мы хотим, чтобы доступ был только для классов из того же пакета, нам не нужно указывать никаких модификаторов доступа    !_Чем отличается статический внутренний класс от просто внутреннего класса?
Внутренний класс - это класс, описанный в теле другого класса. 
Статический внутренний класс не имеет доступа к нестатическим полям и методам внешнего класса. Может описывать статические поля, методы или классы.
Внутренний класс имеет доступ ко всем членам внешнего класса с помощью ключевого слова this. Не может описывать статических полей, методов или классов, но может их наследовать.     !_Можно ли обратиться к не-статической переменной из статического метода?
Статический метод - метод, для работы которого не нужен экземпляр класса, в котором он описан, достаточно просто имени класса. Из-за этого в методе нет ссылки на конкретный объект, вызывавший его (в нестатическом методе это ключевое слово this), которая нужна для обращения к нестатическому полю, поэтому напрямую обратиться не получится    !_какие типы данных есть в Java?
		  В Java существует восемь примитивных типов данных:
byte (8 разрядов)
int (32 разряда)
short (16 разрядов)
long (64 разряда)
float (32 разряда)
double (64 разряда)
boolean (размер не определен)
char (16 разрядов)

У всех этих типов есть свои классы-обертки (их имена - название типа, но начинающееся с большой буквы) использующиеся, когда нужно значение примитивного типа представить в виде объекта
также существуют данные ссылочных типов - это строки, массивы, массивы массивов, объекты (экземпляры классов). 
ссылки хранятся в отдельной области памяти, которая называется стэк
объекты хранятся в другой области памяти, она называется heap (куча)
содержание объектов типа String - литералы, они хранятся в отдельном пуле литералов и при создании нового сначала проверятся, нет ли уже такого литерала в пуле, и если есть, то используется ссылка на тот же объект
  !_Чем отличаются переопределение (Override) и перегрузка (Overload)

Переопределение - это способ уточнить реализацию метода суперкласса в классе-наследнике. Переопределяемый метод должен сохранять сигнатуру (имя, количество/тип/порядок аргументов) метода из суперкласса, при этом меняя само тело метода. Для обозначения перепределения существует аннотация @Override, которая служит указателем компилятору на то, что этот метод должен быть переопределенным методом из суперкласса. Статический метод нельзя переопределить нестатическим, как и наоборот. 
Если нам нужно предотвратить переопределение метода, то нужно использовать модификатор final. Методы с этим модификатором невозможно переопределить.   
Перегрузка - это способ менять, что именно делает метод, в зависимости от аргументов, с которыми он вызывается. У перегруженного метода должно остаться имя оригинального метода, но должна быть другая сигнатура. Для обозначения перегрузки метода используется аннотация @Overload. Статический класс можно перегружать нестатическим, как и наоборот.
   !_Что такое итератор?
Итератор - объект из стандартной библиотеки java.util, который позволяет осуществлять проход (траверс) по коллекции с возможностью удаления элементов, скрывая при этом структуру коллекции от пользователя, позволяя пользоваться коллекцией как списком или простой последовательностью     !_Перечислите основные категории исключительных ситуаций
Исключительная ситуация - аварийное состояние, некая ошибка в работе программы
Делятся на Exception и Error
Error - серьезная ошибка, связанная с работой виртуальной машины (отсутствие свободной памяти и тп)
Exception - ошибки, которые нужно перехватывать и обрабатывать в программе
Exception могут быть проверяемые и непроверяемые

Проверяемые исключительные ситуации могут быть отслежены компилятором, непроверяемые могут быть перехвачены только на этапе времени выполнения     Какая разница между throw и throws?
throws - это ключевое слово, используемое в описании метода. После него перечисляются виды исключительных ситуаций, которые могут возникнуть в ходе работы метода. 
throw - ключевое слово, используемое для явного выбрасывания определенной исключительной ситуации
     !_Зачем нужен блок finally?

Блок finally - это часть структуры try/catch/finally, которая служит для перехвата и обработки исключительных ситуаций. 
Код, который расположен в блоке finally, будет выполнен в любом случае после того, как будет выполнен код в блоке try, вне зависимости от того, будет ли выброшено и обработано исключение или нет. 
В блоке finally стоит располагать код, который должен быть выполнен при любом исходе программы - например, закрытие доступа к файлу.    !_Что такое finalize?
finalize() - метод, в котором описывается то, что должно быть выполнено перед тем, как объект будет уничтожен сборщиком мусора. Однако мы не можем быть уверены в работе сборщика мусора, в какой момент он будет вызван, поэтому этот метод использовать не рекомендуется    !_Перечислите все виды внутренних классов
Статический внутренний класс - описывается в теле внешнего класса с использованием модификатора static, могут иметь статические члены и не имеет доступа к нестатическим членам внешнего класса 
Внутренний класс - также описывается в теле внешнего класса, не может описывать статические члены, но может их наследовать. Имеет доступ ко всем членам внешнего класса с использованием ключевого слова this.
Локальный внутренний класс - описывается внутри метода и используется только внутри этого метода, также не могут описывать статические члены. Имеют доступ к параметрам метода и локальным переменным, при условии что они объявлены final.
Анонимный внутренний класс - описывается внутри метода, ведет себя как локальный внутренний класс, но не имеет имени, главное - чтобы реализовывал один из существующих интерфейсов или наследовал от существующего класса. Также не может описывать статические члены
 
